import { NextResponse } from 'next/server';
import JSZip from 'jszip';
import { supabaseAdmin } from '@/lib/supaClient';

// In-memory cache for temporary download artifacts
// In production, this would be stored in a database or cloud storage
const downloadCache: Record<string, {
  expires: Date,
  serverFiles?: Record<string, string>,
  claudeConfig?: Record<string, string>,
  cursorConfig?: Record<string, string>,
  config?: any
}> = {};

// Store download data in cache
async function storeDownloadData(id: string, data: any): Promise<void> {
  // Set expiration to 1 hour from now
  const expires = new Date();
  expires.setHours(expires.getHours() + 1);
  
  downloadCache[id] = {
    expires,
    ...data
  };
  
  // Clean up expired entries
  cleanupExpiredDownloads();
}

// Clean up expired entries
function cleanupExpiredDownloads(): void {
  const now = new Date();
  
  Object.keys(downloadCache).forEach(id => {
    if (downloadCache[id].expires < now) {
      delete downloadCache[id];
    }
  });
}

// Function to generate server.ts file (TypeScript)
function generateServerTs(config: any): string {
  // If we have the original AI-generated code, use it directly
  if (config.serverCode) {
    return config.serverCode;
  }
  
  // As a fallback, use the template (this preserves backward compatibility)
  const serverTemplate = `// MCP Server generated by buildmcp.space
import { createServer } from '@modelcontextprotocol/sdk';

// Define types for MCP components
interface MCPResource {
  id: string;
  name: string;
  description?: string;
  [key: string]: any;
}

interface MCPTool {
  id: string;
  name: string;
  description?: string;
  parameters?: any;
  [key: string]: any;
}

interface MCPPrompt {
  id: string;
  name: string;
  description?: string;
  text: string;
  [key: string]: any;
}

// MCP server configuration
const resources: MCPResource[] = ${JSON.stringify(config.resources || [], null, 2)};
const tools: MCPTool[] = ${JSON.stringify(config.tools || [], null, 2)};
const prompts: MCPPrompt[] = ${JSON.stringify(config.prompts || [], null, 2)};

const server = createServer({
  resources,
  tools,
  prompts,
  config: {
    name: "${config.metadata?.name || 'MCP Server'}",
    description: "${config.description || ''}"
  }
});

// Start the server
const PORT = process.env.PORT || 3333;
server.listen(PORT, () => {
  console.log(\`MCP Server running at http://localhost:\${PORT}\`);
});
`;

  return serverTemplate;
}

// Generate tsconfig.json
function generateTsConfig(): string {
  return JSON.stringify({
    "compilerOptions": {
      "target": "ES2020",
      "module": "commonjs",
      "esModuleInterop": true,
      "forceConsistentCasingInFileNames": true,
      "strict": true,
      "skipLibCheck": true,
      "outDir": "dist"
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules"]
  }, null, 2);
}

// Generate Claude Desktop config
function generateClaudeConfig(mcpName: string): string {
  const claudeConfig = {
    "mcpServers": {
      [mcpName]: {
        "command": "node",
        "args": [
          "dist/server.js"
        ]
      }
    }
  };
  
  return JSON.stringify(claudeConfig, null, 2);
}

// Generate Cursor config
function generateCursorConfig(mcpId: string, mcpName: string): string {
  // Normalize MCP name for folder - remove spaces and special characters
  const normalizedMcpName = mcpName.replace(/[^a-zA-Z0-9-_]/g, '');
  
  const cursorConfig = {
    "mcpServers": {
      [`${normalizedMcpName}`]: {
        "command": "node",
        "args": [
          `./${normalizedMcpName}/dist/server.js`
        ]
      }
    }
  };
  
  return JSON.stringify(cursorConfig, null, 2);
}

// Generate package.json with TypeScript dependencies
function generatePackageJson(mcpName: string): string {
  const packageJson = {
    "name": mcpName,
    "version": "1.0.0",
    "description": "MCP Server generated by buildmcp.space",
    "main": "dist/server.js",
    "scripts": {
      "build": "tsc -b",
      "start": "node dist/server.js",
      "dev": "ts-node src/server.ts"
    },
    "dependencies": {
      "@modelcontextprotocol/sdk": "^1.0.0"
    },
    "devDependencies": {
      "@types/node": "^20.5.0",
      "typescript": "^5.1.6",
      "ts-node": "^10.9.1"
    }
  };
  
  return JSON.stringify(packageJson, null, 2);
}

// Generate README with instructions for TypeScript
function generateReadme(mcpName: string): string {
  return `# MCP Server (${mcpName.substring(0, 6)})

This MCP server was generated by buildmcp.space.

## Installation

1. Make sure you have Node.js installed (download from https://nodejs.org/)
2. Run \`npm install\` to install dependencies
3. Run \`npm run build\` to compile TypeScript to JavaScript
4. Run \`npm start\` to start the server

## Development

- Source files are in the \`src\` directory in TypeScript
- Use \`npm run dev\` to run the server in development mode
- Use \`npm run build\` to compile TypeScript to JavaScript

## Client Configuration

### Claude Desktop

1. Open Claude Desktop
2. Go to Settings > Servers
3. Add a new server with the following configuration:
   - Name: MCP Server (${mcpName.substring(0, 6)})
   - Path to server: Use the path to the running server
   - Alternatively, edit your Claude Desktop config to include the contents of \`claude_desktop_config.json\`

### Cursor

1. Create a \`.cursor\` directory in your project root (if it doesn't exist)
2. Copy \`mcp.json\` to the \`.cursor\` directory
3. Restart Cursor

## Files

- \`src/server.ts\`: The main server file (TypeScript source)
- \`dist/server.js\`: The compiled JavaScript file (generated after build)
- \`tsconfig.json\`: TypeScript configuration
- \`package.json\`: Node.js package configuration
- \`claude_desktop_config.json\`: Configuration for Claude Desktop
- \`mcp.json\`: Configuration for Cursor
- \`install.bat\`: Windows installation script
- \`install.sh\`: Mac/Linux installation script
`;
}

// Generate installation scripts for Windows and Unix
function generateInstallScripts(): { windows: string, unix: string } {
  const windowsScript = `@echo off
echo Installing MCP Server...
call npm install
echo Building TypeScript...
call npm run build
echo Installation complete!
echo Run 'npm start' to start the server
pause
`;

  const unixScript = `#!/bin/bash
echo "Installing MCP Server..."
npm install
echo "Building TypeScript..."
npm run build
echo "Installation complete!"
echo "Run 'npm start' to start the server"
`;

  return {
    windows: windowsScript,
    unix: unixScript
  };
}

// Improved function to extract token from request
async function authenticate(request: Request): Promise<{ user: any | null, error: string | null }> {
  try {
    console.log('Starting authentication process...');
    const cookieHeader = request.headers.get('cookie');
    console.log('Cookie header exists:', !!cookieHeader);
    
    let token = null;
    
    // Method 1: Try the Authorization header
    const authHeader = request.headers.get('authorization');
    if (authHeader) {
      token = authHeader.replace('Bearer ', '');
      console.log('Auth token found in header:', token.substring(0, 15) + '...');
      
      // Validate token
      const { data, error } = await supabaseAdmin!.auth.getUser(token);
      
      if (error) {
        console.error('Auth error from header token:', error);
      } else if (data.user) {
        console.log('Valid auth from header token, user ID:', data.user.id);
        return { user: data.user, error: null };
      }
    } else {
      console.log('No Authorization header present');
    }
    
    // Method 2: Try extracting from cookies
    if (cookieHeader) {
      // Log all cookies for debugging
      console.log('Cookies:', cookieHeader);
      
      // Try to match any of these possible cookie patterns
      const cookiePatterns = [
        /sb-access-token=([^;]+)/,
        /sb-access-token-client=([^;]+)/,
        /access_token=([^;]+)/
      ];
      
      for (const pattern of cookiePatterns) {
        const match = cookieHeader.match(pattern);
        if (match && match[1]) {
          token = match[1];
          console.log('Auth token found in cookie:', token.substring(0, 15) + '...');
          
          // Validate token
          const { data, error } = await supabaseAdmin!.auth.getUser(token);
          
          if (error) {
            console.error('Auth error from cookie token:', error);
          } else if (data.user) {
            console.log('Valid auth from cookie token, user ID:', data.user.id);
            return { user: data.user, error: null };
          }
        }
      }
    }
    
    // Method 3: Check for a logged-in session in cookies
    try {
      // Extract all cookies and build a cookie string
      const cookies: Record<string, string> = {};
      if (cookieHeader) {
        cookieHeader.split(';').forEach(cookie => {
          const parts = cookie.trim().split('=');
          if (parts.length === 2) {
            cookies[parts[0]] = parts[1];
          }
        });
      }
      
      console.log('Trying session check with cookies...');
      // Try with supabaseAdmin's session check (which uses cookies)
      const { data, error } = await supabaseAdmin!.auth.getSession();
      
      if (error) {
        console.error('Error getting session from cookies:', error);
      } else if (data.session?.user) {
        console.log('Valid session found in cookies, user ID:', data.session.user.id);
        return { user: data.session.user, error: null };
      }
    } catch (sessionError) {
      console.error('Error during cookie session check:', sessionError);
    }
    
    // Method 4: Special case for cross-site downloads
    // This is a fallback method that doesn't require a token
    // It works by checking if the userId parameter matches the user ID in the MCP
    const url = new URL(request.url);
    const userId = url.searchParams.get('userId');
    
    if (userId) {
      console.log('Using userId parameter for cross-site auth:', userId);
      return { user: { id: userId }, error: null };
    }
    
    console.log('No valid authentication token found');
    return { user: null, error: 'Authorization required. Please sign in.' };
  } catch (error) {
    console.error('Authentication error:', error);
    return { user: null, error: 'Authentication failed due to server error' };
  }
}

// GET /api/mcp/download/[id]/[type]
export async function GET(request: Request, { params }: { params: { id: string, type: string } }) {
  try {
    const { id, type } = params;
    console.log(`Download request for MCP ${id}, type: ${type}`);
    
    // Check if download exists in cache
    if (!downloadCache[id]) {
      // Try to find in Supabase
      if (supabaseAdmin) {
        // First check if this is a deployment ID
        const { data: deploymentData, error: deploymentError } = await supabaseAdmin
          .from('mcp_deployments')
          .select('config, project_id')
          .eq('id', id)
          .single();
          
        let projectId = id;
        let mcpConfig = null;
        let mcpCode = null;
        let mcpName = '';
        
        if (deploymentError || !deploymentData) {
          // If not a deployment, try to find the MCP project directly
          const { data: mcpData, error: mcpError } = await supabaseAdmin
            .from('mcp_projects')
            .select('config, id, code, is_public, user_id, name')
            .eq('id', id)
            .single();
            
          if (mcpError || !mcpData) {
            console.error('MCP data not found in Supabase:', mcpError);
            return NextResponse.json({ error: 'MCP not found' }, { status: 404 });
          }
          
          // Check if MCP is public or verify authentication
          if (!mcpData.is_public) {
            // Authenticate the user
            const { user, error: authError } = await authenticate(request);
            
            if (authError || !user) {
              console.error('Authentication failed:', authError);
              return NextResponse.json({ 
                error: authError || 'Authentication failed', 
                isPrivate: true 
              }, { status: 401 });
            }
            
            // Verify user has permission
            if (user.id !== mcpData.user_id) {
              console.error('Permission denied for user:', user.id, 'trying to access MCP owned by:', mcpData.user_id);
              return NextResponse.json({ 
                error: 'You do not have permission to download this MCP', 
                isPrivate: true 
              }, { status: 403 });
            }
            
            console.log('User authenticated and authorized to download MCP');
          }
          
          // Add the original code to the config if it exists
          mcpConfig = mcpData.config;
          mcpCode = mcpData.code;
          projectId = mcpData.id;
          mcpName = mcpData.name || `mcp-${projectId.substring(0, 6)}`;
        } else {
          // We found a deployment, get the associated MCP project
          const { data: mcpData, error: mcpError } = await supabaseAdmin
            .from('mcp_projects')
            .select('config, code, is_public, user_id, name')
            .eq('id', deploymentData.project_id)
            .single();
            
          if (mcpError || !mcpData) {
            return NextResponse.json({ error: 'MCP not found' }, { status: 404 });
          }
          
          // Check if MCP is public or verify authentication
          if (!mcpData.is_public) {
            // Authenticate the user
            const { user, error: authError } = await authenticate(request);
            
            if (authError || !user) {
              console.error('Authentication failed:', authError);
              return NextResponse.json({ 
                error: authError || 'Authentication failed', 
                isPrivate: true 
              }, { status: 401 });
            }
            
            // Verify user has permission
            if (user.id !== mcpData.user_id) {
              console.error('Permission denied for user:', user.id, 'trying to access MCP owned by:', mcpData.user_id);
              return NextResponse.json({ 
                error: 'You do not have permission to download this MCP', 
                isPrivate: true 
              }, { status: 403 });
            }
            
            console.log('User authenticated and authorized to download MCP');
          }
          
          // Add the original code to the config if it exists
          mcpConfig = mcpData.config;
          mcpCode = mcpData.code;
          projectId = deploymentData.project_id;
          mcpName = mcpData.name || `mcp-${projectId.substring(0, 6)}`;
        }
        
        // If we have code, add it to the config
        if (mcpCode && mcpConfig) {
          mcpConfig.serverCode = mcpCode;
        }
        
        // Normalize the MCP name for folder
        const normalizedMcpName = mcpName.replace(/[^a-zA-Z0-9-_]/g, '');
        
        // Store in cache
        await storeDownloadData(id, {
          config: mcpConfig,
          serverFiles: {
            'src/server.ts': generateServerTs(mcpConfig),
            'tsconfig.json': generateTsConfig(),
            'package.json': generatePackageJson(normalizedMcpName),
            'README.md': generateReadme(normalizedMcpName),
            'install.bat': generateInstallScripts().windows,
            'install.sh': generateInstallScripts().unix
          },
          claudeConfig: {
            'claude_desktop_config.json': generateClaudeConfig(normalizedMcpName)
          },
          cursorConfig: {
            'mcp.json': generateCursorConfig(projectId, normalizedMcpName)
          }
        });
      } else {
        return NextResponse.json({ error: 'Download not available' }, { status: 404 });
      }
    }
    
    const downloadData = downloadCache[id];
    if (!downloadData) {
      return NextResponse.json({ error: 'Download not available' }, { status: 404 });
    }
    
    // Create a zip file based on the requested type
    const zip = new JSZip();
    
    switch (type) {
      case 'server':
        // Add server files
        if (downloadData.serverFiles) {
          Object.entries(downloadData.serverFiles).forEach(([filename, content]) => {
            // Create directories if filename contains path separators
            if (filename.includes('/')) {
              const parts = filename.split('/');
              const fileName = parts.pop() || '';
              
              // Create folder structure
              let currentFolder = zip;
              for (const dir of parts) {
                const folder = currentFolder.folder(dir);
                if (folder) {
                  currentFolder = folder;
                }
              }
              
              // Add file to the correct folder
              currentFolder.file(fileName, content);
            } else {
              zip.file(filename, content);
            }
          });
        }
        break;
        
      case 'claude':
        // Add Claude Desktop config
        if (downloadData.claudeConfig) {
          Object.entries(downloadData.claudeConfig).forEach(([filename, content]) => {
            zip.file(filename, content);
          });
        }
        break;
        
      case 'cursor':
        // Add Cursor config
        if (downloadData.cursorConfig) {
          Object.entries(downloadData.cursorConfig).forEach(([filename, content]) => {
            zip.file(filename, content);
          });
        }
        break;
        
      case 'bundle':
        // Add all files
        if (downloadData.serverFiles) {
          Object.entries(downloadData.serverFiles).forEach(([filename, content]) => {
            // Create directories if filename contains path separators
            if (filename.includes('/')) {
              const parts = filename.split('/');
              const fileName = parts.pop() || '';
              
              // Create folder structure
              let currentFolder = zip;
              for (const dir of parts) {
                const folder = currentFolder.folder(dir);
                if (folder) {
                  currentFolder = folder;
                }
              }
              
              // Add file to the correct folder
              currentFolder.file(fileName, content);
            } else {
              zip.file(filename, content);
            }
          });
        }
        
        if (downloadData.claudeConfig) {
          Object.entries(downloadData.claudeConfig).forEach(([filename, content]) => {
            zip.file(filename, content);
          });
        }
        
        if (downloadData.cursorConfig) {
          Object.entries(downloadData.cursorConfig).forEach(([filename, content]) => {
            zip.file(filename, content);
          });
        }
        break;
        
      default:
        return NextResponse.json({ error: 'Invalid download type' }, { status: 400 });
    }
    
    // Generate the zip file
    const zipContent = await zip.generateAsync({ type: 'nodebuffer' });
    
    // Prepare the response with appropriate headers
    const response = new NextResponse(zipContent);
    
    // Set headers
    response.headers.set('Content-Type', 'application/zip');
    response.headers.set('Content-Disposition', `attachment; filename="mcp-${type}-${id.substring(0, 6)}.zip"`);
    
    return response;
  } catch (error) {
    console.error('Error generating download:', error);
    return NextResponse.json({ error: 'Failed to generate download' }, { status: 500 });
  }
} 